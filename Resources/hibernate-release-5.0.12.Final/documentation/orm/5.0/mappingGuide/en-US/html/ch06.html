<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 6. Identifiers</title><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><meta name="description" content="This chapter discusses the characteristics of entity identifier attributes and modelling them."/><link rel="home" href="index.html" title="Hibernate Domain Model Mapping Guide"/><link rel="up" href="index.html" title="Hibernate Domain Model Mapping Guide"/><link rel="prev" href="ch05.html" title="Chapter 5. Collections"/><link rel="next" href="ch07.html" title="Chapter 7. Natural Ids"/><meta xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p xmlns:d="http://docbook.org/ns/docbook" id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch05.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch07.html"><strong>Next</strong></a></li></ul><div xml:lang="en" class="chapter" title="Chapter 6. Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers"/>Chapter 6. Identifiers</h2></div><div><div class="abstract" title="Abstract"><p class="title"><strong>Abstract</strong></p>
            <p>
                This chapter discusses the characteristics of entity identifier attributes and modelling
                them.
            </p>
        </div></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="ch06.html#identifiers-simple">6.1. Simple identifiers</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-composite">6.2. Composite identifiers</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#identifiers-composite-aggregated">6.2.1. Composite identifiers - aggregated (EmbeddedId)</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-composite-nonaggregated">6.2.2. Composite identifiers - non-aggregated (IdClass)</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#identifiers-generators">6.3. Generated identifier values</a></span></dt><dd><dl><dt><span class="section"><a href="ch06.html#identifiers-generators-auto">6.3.1. Interpreting AUTO</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-sequence">6.3.2. Using sequences</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-identity">6.3.3. Using IDENTITY columns</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-table">6.3.4. Using identifier table</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-uuid">6.3.5. Using UUID generation</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-generic">6.3.6. Using @GenericGenerator</a></span></dt><dt><span class="section"><a href="ch06.html#identifiers-generators-optimizer">6.3.7. Optimizers</a></span></dt></dl></dd><dt><span class="section"><a href="ch06.html#identifiers-derived">6.4. Derived Identifiers</a></span></dt></dl></div>

    

    <p>
        Identifiers model the primary key of an entity.  They are used to uniquely identify each specific entity.
    </p>

    <p>
        Hibernate and JPA both make the following assumptions about the corresponding database column(s):
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                <p>
                    <code class="literal">UNIQUE</code> - The values must uniquely identify each row.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">NOT NULL</code> - The values cannot be null.  For composite ids, no part can be null.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">IMMUTABLE</code> - The values, once inserted, can never be changed.  This is more
                    a general guide, than a hard-fast rule as opinions vary.  JPA defines the behavior of changing the
                    value of the identifier attribute to be undefined; Hibernate simply does not support that.  In cases
                    where the values for the PK you have chosen will be updated, Hibernate recommends mapping the
                    mutable value as a natural id, and use a surrogate id for the PK.  See <a class="xref" href="ch07.html" title="Chapter 7. Natural Ids">Chapter 7, <em>Natural Ids</em></a>.
                </p>
            </li></ul></div><p>
    </p>

    <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
        <p>
            Technically the identifier does not have to map to the column(s) physically defined as the entity
            table's primary key.  They just need to map to column(s) that uniquely identify each row.  However
            this documentation will continue to use the terms identifier and primary key interchangeably.
        </p>
    </div>

    <p>
        Every entity must define an identifier.  For entity inheritance hierarchies, the identifier must be
        defined just on the entity that is the root of the hierarchy.
    </p>

    <p>
        An identifier might be simple (single value) or composite (multiple values).
    </p>

    <div class="section" title="6.1. Simple identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers-simple"/>6.1. Simple identifiers</h2></div></div></div>
        
        <p>
            Simple identifiers map to a single basic attribute, and are denoted using the
            <code class="interfacename">javax.persistence.Id</code> annotation.
        </p>

        <p>
            According to JPA only the following types should be used as identifier attribute types:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>any Java primitive type</p></li><li class="listitem"><p>any primitive wrapper type</p></li><li class="listitem"><p>java.lang.String</p></li><li class="listitem"><p>java.util.Date (TemporalType#DATE)</p></li><li class="listitem"><p>java.sql.Date</p></li><li class="listitem"><p>java.math.BigDecimal</p></li><li class="listitem"><p>java.math.BigInteger</p></li></ul></div><p>
            Any types used for identifier attributes beyond this list will not be portable.
        </p>

        <p>
            Values for simple identifiers can be assigned, as we have seen in the examples above.  The expectation
            for assigned identifier values is that the application assigns (sets them on the entity attribute) prior
            to calling save/persist.
        </p>

        <div class="example"><a id="d5e992"/><p class="title"><strong>Example 6.1. Simple assigned identifier</strong></p><div class="example-contents">
            
            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	public Integer id;
	...
}</pre>
        </div></div><br class="example-break"/>

        <p>
            Values for simple identifiers can be generated.  To denote that an identifier attribute is
            generated, it is annotated with <code class="interfacename">javax.persistence.GeneratedValue</code>
        </p>

        <div class="example"><a id="d5e997"/><p class="title"><strong>Example 6.2. Simple generated identifier</strong></p><div class="example-contents">
            
            <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue
	public Integer id;
	...
}</pre>
        </div></div><br class="example-break"/>

        <p>
            Additionally to the type restriction list above, JPA
            says that if using generated identifier values (see below) only integer types (short, int, long) will be
            portably supported.
        </p>

        <p>
            The expectation for generated identifier values is that Hibernate will generate the value
            when the save/persist occurs.
        </p>

        <p>
            Identifier value generations strategies are discussed in detail in <a class="xref" href="ch06.html#identifiers-generators" title="6.3. Generated identifier values">Section 6.3, “Generated identifier values”</a>.
        </p>
    </div>

    <div class="section" title="6.2. Composite identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers-composite"/>6.2. Composite identifiers</h2></div></div></div>
        

        <p>
            Composite identifiers correspond to one or more persistent attributes.  Here are the rules governing
            composite identifiers, as defined by the JPA specification.
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                    <p>
                        The composite identifier must be represented by a "primary key class".  The primary key class
                        may be defined using the <code class="interfacename">javax.persistence.EmbeddedId</code> annotation
                        (see <a class="xref" href="ch06.html#identifiers-composite-aggregated" title="6.2.1. Composite identifiers - aggregated (EmbeddedId)">Section 6.2.1, “Composite identifiers - aggregated (EmbeddedId)”</a>) or defined using the
                        <code class="interfacename">javax.persistence.IdClass</code> annotation (see
                        <a class="xref" href="ch06.html#identifiers-composite-nonaggregated" title="6.2.2. Composite identifiers - non-aggregated (IdClass)">Section 6.2.2, “Composite identifiers - non-aggregated (IdClass)”</a>).
                    </p>
                </li><li class="listitem">
                    <p>
                        The primary key class must be public and must have a public no-arg constructor.
                    </p>
                </li><li class="listitem">
                    <p>
                        The primary key class must be serializable.
                    </p>
                </li><li class="listitem">
                    <p>
                        The primary key class must define equals and hashCode methods, consistent with equality for
                        the underlying database types to which the key is mapped.
                    </p>
                </li></ul></div><p>
        </p>

        <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                The restriction that a composite identifier has to be represented by a "primary key class" is
                a JPA restriction.  Hibernate does allow composite identifiers to be defined without a
                "primary key class", but use of that modeling technique is deprecated and not discussed here.
            </p>
        </div>

        <p>
            The attributes making up the composition can be either basic, composite, ManyToOne.  Note especially
            that collections and one-to-ones are never appropriate.
            
        </p>

        <div class="section" title="6.2.1. Composite identifiers - aggregated (EmbeddedId)"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-composite-aggregated"/>6.2.1. Composite identifiers - aggregated (EmbeddedId)</h3></div></div></div>
            

            <p>
                Modelling a composite identifier using an EmbeddedId simply means defining an
                Embeddable to be a composition for the the one or more attributes making up the
                identifier and then exposing an attribute of that Embeddable type on the entity.
            </p>

            <div class="example"><a id="d5e1026"/><p class="title"><strong>Example 6.3. Basic EmbeddedId</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class Login {
	@Embeddable
	public static class PK implements Serializable  {
		private String system;
		private String username;
		...
	}

	@EmbeddedId
	private PK pk;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                As mentioned before, EmbeddedIds can even contain ManyToOne attributes.
            </p>

            <div class="example"><a id="d5e1030"/><p class="title"><strong>Example 6.4. EmbeddedId with ManyToOne</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class Login {
	@Embeddable
	public static class PK implements Serializable {
		@ManyToOne
		private System system;
		private String username;
		...
	}

	@EmbeddedId
	private PK pk;
	...
}</pre>
            </div></div><br class="example-break"/>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    Hibernate supports directly modeling the ManyToOne in the PK class, whether EmbeddedId or IdClass.
                    However that is not portably supported by the JPA specification.  In JPA terms one would
                    use "derived identifiers"; for details, see <a class="xref" href="ch06.html#identifiers-derived" title="6.4. Derived Identifiers">Section 6.4, “Derived Identifiers”</a>.
                </p>
            </div>
        </div>

        <div class="section" title="6.2.2. Composite identifiers - non-aggregated (IdClass)"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-composite-nonaggregated"/>6.2.2. Composite identifiers - non-aggregated (IdClass)</h3></div></div></div>
            

            <p>
                Modelling a composite identifier using an IdClass differs from using an EmbeddedId in that the entity
                defines each individual attribute making up the composition.  The IdClass simply acts as a "shadow".
            </p>

            <div class="example"><a id="d5e1039"/><p class="title"><strong>Example 6.5. Basic IdClass</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
@IdClass(PK.class)
public class Login {
	public static class PK implements Serializable  {
		private String system;
		private String username;
		...
	}

	@Id
	private String system;
	@Id
	private String username;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                Non-aggregated composite identifiers can also contain ManyToOne attributes as we saw with aggregated
                ones (still non-portably)
            </p>

            <div class="example"><a id="d5e1043"/><p class="title"><strong>Example 6.6. IdClass with ManyToOne</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
@IdClass(PK.class)
public class Login {
	public static class PK implements Serializable {
		private System system;
		private String username;
		...
	}

	@Id
	@ManyToOne
	private System system;
	@Id
	private String username;

	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                With non-aggregated composite identifiers, Hibernate also supports "partial" generation of the
                composite values.
            </p>

            <div class="example"><a id="d5e1047"/><p class="title"><strong>Example 6.7. IdClass with partial generation</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
@IdClass(PK.class)
public class LogFile {
	public static class PK implements Serializable {
		private String name;
		private LocalDate date;
		private Integer uniqueStamp;
		...
	}

	@Id
	private String name;
	@Id
	private LocalDate date;
	@Id
	@GeneratedValue
	private Integer uniqueStamp;
	...
}

</pre>
            </div></div><br class="example-break"/>

            <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
                <p>
                    This feature exists because of a highly questionable interpretation of the JPA specification
                    made by the SpecJ committee.  Hibernate does not feel that JPA defines support for this, but
                    added the feature simply to be usable in SpecJ benchmarks.  Use of this feature may or may not
                    be portable from a JPA perspective.
                </p>
            </div>
        </div>

    </div>

    <div class="section" title="6.3. Generated identifier values"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers-generators"/>6.3. Generated identifier values</h2></div></div></div>
        

        

        <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                For discussion of generated values for non-identifier attributes, see <a class="xref" href="">???</a>
            </p>
        </div>

        <p>
            Hibernate supports identifier value generation across a number of different types.  Remember
            that JPA portably defines identifier value generation just for integer types.
        </p>

        <p>
            Identifier value generation is indicates using the <code class="interfacename">javax.persistence.GeneratedValue</code>
            annotation.  The most important piece of information here is the specified
            <code class="interfacename">javax.persistence.GenerationType</code> which indicates how values will be generated.
        </p>

        <div xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2>
            <p>
                The discussions below assume that the application is using Hibernate's "new generator mappings" as
                indicated by the <code class="literal">hibernate.id.new_generator_mappings</code> setting or
                <code class="methodname">MetadataBuilder.enableNewIdentifierGeneratorSupport</code> method during bootstrap.
                This is set to true by default, however if applications set this to false the resolutions discussed
                here will be very different.  The rest of the discussion here assumes this setting is enabled (true).
            </p>
        </div>

        <div class="itemizedlist" title="GenerationTypes"><p class="title"><strong>GenerationTypes</strong></p><ul class="itemizedlist"><li class="listitem">
                <p>
                    <code class="literal">AUTO</code> (the default) - Indicates that the persistence provider (Hibernate) should
                    chose an appropriate generation strategy.  See <a class="xref" href="ch06.html#identifiers-generators-auto" title="6.3.1. Interpreting AUTO">Section 6.3.1, “Interpreting AUTO”</a>.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">IDENTITY</code> - Indicates that database IDENTITY columns will be used for
                    primary key value generation.  See <a class="xref" href="ch06.html#identifiers-generators-identity" title="6.3.3. Using IDENTITY columns">Section 6.3.3, “Using IDENTITY columns”</a>.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">SEQUENCE</code> - Indicates that database sequence should be used for obtaining
                    primary key values.   See <a class="xref" href="ch06.html#identifiers-generators-sequence" title="6.3.2. Using sequences">Section 6.3.2, “Using sequences”</a>.
                </p>
            </li><li class="listitem">
                <p>
                    <code class="literal">TABLE</code> - Indicates that a database table should be used for obtaining
                    primary key values.   See <a class="xref" href="ch06.html#identifiers-generators-table" title="6.3.4. Using identifier table">Section 6.3.4, “Using identifier table”</a>.
                </p>
            </li></ul></div>

        <div class="section" title="6.3.1. Interpreting AUTO"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-auto"/>6.3.1. Interpreting AUTO</h3></div></div></div>
            

            <p>
                How a persistence provider interprets the AUTO generation type is left up to the provider.  Hibernate
                interprets it in the following order:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            If the given name matches the name for a <code class="interfacename">javax.persistence.SequenceGenerator</code>
                            annotation -&gt; <a class="xref" href="ch06.html#identifiers-generators-sequence" title="6.3.2. Using sequences">Section 6.3.2, “Using sequences”</a>.
                        </p>
                    </li><li class="listitem">
                        <p>
                            If the given name matches the name for a <code class="interfacename">javax.persistence.TableGenerator</code>
                            annotation -&gt; <a class="xref" href="ch06.html#identifiers-generators-table" title="6.3.4. Using identifier table">Section 6.3.4, “Using identifier table”</a>.
                        </p>
                    </li><li class="listitem">
                        <p>
                            If the given name matches the name for a <code class="interfacename">org.hibernate.annotations.GenericGenerator</code>
                            annotation -&gt; <a class="xref" href="ch06.html#identifiers-generators-generic" title="6.3.6. Using @GenericGenerator">Section 6.3.6, “Using @GenericGenerator”</a>.
                        </p>
                    </li></ul></div><p>
                The fallback is to consult with the pluggable <code class="interfacename">org.hibernate.boot.model.IdGeneratorStrategyInterpreter</code>
                contract, which is covered in detail in the <em class="citetitle">Hibernate Integrations Guide</em>.  The default
                behavior is to look at the java type of the identifier attribute:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            If it is UUID -&gt; <a class="xref" href="ch06.html#identifiers-generators-uuid" title="6.3.5. Using UUID generation">Section 6.3.5, “Using UUID generation”</a>
                        </p>
                    </li><li class="listitem">
                        <p>
                            Otherwise -&gt; <a class="xref" href="ch06.html#identifiers-generators-sequence" title="6.3.2. Using sequences">Section 6.3.2, “Using sequences”</a>
                        </p>
                    </li></ul></div><p>
            </p>
        </div>

        <div class="section" title="6.3.2. Using sequences"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-sequence"/>6.3.2. Using sequences</h3></div></div></div>
            

            <p>
                For implementing database sequence-based identifier value generation Hibernate makes use of its
                <code class="classname">org.hibernate.id.enhanced.SequenceStyleGenerator</code> id generator.  It is important
                to note that SequenceStyleGenerator is capable of working against databases that do not support sequences
                by switching to a table as the underlying backing.  This gives Hibernate a huge degree of portability
                across databases while still maintaining consistent id generation behavior (versus say choosing
                between sequence and IDENTITY).  This backing storage is completely transparent to the user.
            </p>

            <p>
                The preferred (and portable) way to configure this generator is using the JPA-defined
                <code class="interfacename">javax.persistence.SequenceGenerator</code> annotation.
            </p>

            <p>
                The simplest form is to simply request sequence generation; Hibernate will use a single, implicitly-named
                sequence (<code class="literal">hibernate_sequence</code>) for all such unnamed definitions.
            </p>

            <div class="example"><a id="d5e1116"/><p class="title"><strong>Example 6.8. Unnamed sequence</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue(generation=SEQUENCE)
	public Integer id;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                Or a specifically named sequence can be requested
            </p>

            <div class="example"><a id="d5e1120"/><p class="title"><strong>Example 6.9. Named sequence</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue(generation=SEQUENCE, name="my_sequence")
	public Integer id;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                Use <code class="interfacename">javax.persistence.SequenceGenerator</code> to specify additional configuration.
            </p>

            <div class="example"><a id="d5e1125"/><p class="title"><strong>Example 6.10. Configured sequence</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue(generation=SEQUENCE, name="my_sequence")
	@SequenceGenerator( name = "my_sequence", schema = "globals", allocationSize = 30 )
	public Integer id;
	...
}</pre>
            </div></div><br class="example-break"/>

            
        </div>

        <div class="section" title="6.3.3. Using IDENTITY columns"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-identity"/>6.3.3. Using IDENTITY columns</h3></div></div></div>
            

            <p>
                For implementing identifier value generation based on IDENTITY columns, Hibernate makes use of its
                <code class="classname">org.hibernate.id.IdentityGenerator</code> id generator which expects the identifier
                to generated by INSERT into the table.  IdentityGenerator understands 3 different ways that the
                INSERT-generated value might be retrieved:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
                        <p>
                            If Hibernate believes the JDBC environment supports <code class="methodname">java.sql.Statement#getGeneratedKeys</code>,
                            then that approach will be used for extracting the IDENTITY generated keys.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Otherwise, if <code class="methodname">Dialect#supportsInsertSelectIdentity</code> reports
                            true, Hibernate will use the Dialect specific INSERT+SELECT statement syntax.
                        </p>
                    </li><li class="listitem">
                        <p>
                            Otherwise, Hibernate will expect that the database supports some form of asking
                            for the most recently inserted IDENTITY value via a separate SQL command as
                            indicated by <code class="methodname">Dialect#getIdentitySelectString</code>
                        </p>
                    </li></ul></div><p>
            </p>

            <p>
                It is important to realize that this imposes a runtime behavior where the entity row *must* be
                physically inserted prior to the identifier value being known.  This can mess up extended persistence
                contexts (conversations).  Because of the runtime imposition/inconsistency Hibernate suggest other
                forms of identifier value generation be used.
            </p>

            <p>
                There is yet another important runtime impact of choosing IDENTITY generation: Hibernate will not
                be able to JDBC batching for inserts of the entities that use IDENTITY generation.  The importance
                of this depends on the application's specific use cases.  If the application is not usually
                creating many new instances of a given type of entity that uses IDENTITY generation, then
                this is not an important impact since batching would not have been helpful anyway.
            </p>
        </div>

        <div class="section" title="6.3.4. Using identifier table"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-table"/>6.3.4. Using identifier table</h3></div></div></div>
            

            <p>
                Hibernate achieves table-based identifier generation based on its
                <code class="interfacename">org.hibernate.id.enhanced.TableGenerator</code> id generator which defines
                a table capable of holding multiple named value segments for any number of entities.
            </p>

            <div class="example"><a id="d5e1148"/><p class="title"><strong>Example 6.11. Table generator table structure</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">create table hibernate_sequences(
    sequence_name VARCHAR NOT NULL,
    next_val INTEGER NOT NULL
)</pre>
            </div></div><br class="example-break"/>

            <p>
                The basic idea is that a given table-generator table (<code class="literal">hibernate_sequences</code> for example)
                can hold multiple segments of identifier generation values.
            </p>

            <div class="example"><a id="d5e1153"/><p class="title"><strong>Example 6.12. Unnamed table generator</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue(generation=TABLE)
	public Integer id;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                If no table name is given Hibernate assumes an implicit name of <code class="literal">hibernate_sequences</code>.
                Additionally, because no <code class="methodname">javax.persistence.TableGenerator#pkColumnValue</code> is
                specified, Hibernate will use the default segment (<code class="literal">sequence_name='default'</code>) from the
                hibernate_sequences table.
            </p>

            
        </div>

        <div class="section" title="6.3.5. Using UUID generation"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-uuid"/>6.3.5. Using UUID generation</h3></div></div></div>
            

            <p>
                As mentioned above, Hibernate supports UUID identifier value generation.  This is supported through its
                <code class="classname">org.hibernate.id.UUIDGenerator</code> id generator.
            </p>

            <p>
                UUIDGenerator supports pluggable strategies for exactly how the UUID is generated.  These strategies
                are defined by the <code class="interfacename">org.hibernate.id.UUIDGenerationStrategy</code> contract.
                The default strategy is a version 4 (random) strategy according to IETF RFC 4122.  Hibernate does ship
                with an alternative strategy which is a RFC 4122 version 1 (time-based) strategy (using ip address
                rather than mac address).
            </p>

            <div class="example"><a id="d5e1166"/><p class="title"><strong>Example 6.13. Implicitly using the random UUID strategy</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue
	public UUID id;
	...
}</pre>
            </div></div><br class="example-break"/>

            <p>
                To specify an alternative generation strategy, we'd have to define some configuration via
                @GenericGenerator.  Here we choose the RFC 4122 version 1 compliant strategy named
                <code class="classname">org.hibernate.id.uuid.CustomVersionOneStrategy</code>
            </p>

            <div class="example"><a id="d5e1171"/><p class="title"><strong>Example 6.14. Implicitly using the random UUID strategy</strong></p><div class="example-contents">
                
                <pre xmlns="" xmlns:d="http://docbook.org/ns/docbook" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="">@Entity
public class MyEntity {
	@Id
	@GeneratedValue( generator="uuid" )
	@GenericGenerator(
			name="uuid",
			strategy="org.hibernate.id.UUIDGenerator",
			parameters = {
					@Parameter(
							name="uuid_gen_strategy_class",
							value="org.hibernate.id.uuid.CustomVersionOneStrategy"
					)
			}
	)
	public UUID id;
	...
}</pre>
            </div></div><br class="example-break"/>

        </div>

        <div class="section" title="6.3.6. Using @GenericGenerator"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-generic"/>6.3.6. Using @GenericGenerator</h3></div></div></div>
            
            <p>
                @GenericGenerator allows integration of any Hibernate <code class="interfacename">org.hibernate.id.IdentifierGenerator</code>
                implementation, including any of the specific ones discussed here and any custom ones.
            </p>
        </div>

        <div class="section" title="6.3.7. Optimizers"><div class="titlepage"><div><div><h3 class="title"><a id="identifiers-generators-optimizer"/>6.3.7. Optimizers</h3></div></div></div>
            

            <p>
                Most of the Hibernate generators that separately obtain identifier values from database structures
                support the use of pluggable optimizers.  Optimizers help manage the number of times Hibernate
                has to talk to the database in order to generate identifier values.  For example, with no optimizer
                applied to a sequence-generator, everytime the application asked Hibernate to generate an identifier
                it would need to grab the next sequence value from the database.  But if we can minimize the
                number of times we need to communicate with the database here, the application will be able to perform
                better.  Which is in fact the role of these optimizers.
            </p>

            <div class="variablelist"><dl><dt><span class="term">none</span></dt><dd>
                        <p>
                            No optimization is performed.  We communicate with the database each and every time
                            an identifier value is needed from the generator.
                        </p>
                    </dd><dt><span class="term">pooled-lo</span></dt><dd>
                        <p>
                            The pooled-lo optimizer works on the principle that the increment-value is encoded into
                            the database table/sequence structure.  In sequence-terms this means that the sequence
                            is defined with a greater-that-1 increment size.  For example, consider a brand new sequence
                            defined as <code class="literal">create sequence my_sequence start with 1 increment by 20</code>.
                            This sequence essentially defines a "pool" of 20 usable id values each and every time
                            we ask it for its next-value.  The pooled-lo optimizer interprets the next-value as the
                            low end of that pool.  So when we first ask it for next-value, we'd get 1.  We then assume
                            that the valid pool would be the values from 1-20 inclusive.  The next call to
                            the sequence would result in 21, which would define 21-40 as the valid range.  And so on.
                            The "lo" part of the name indicates that the value from the database table/sequence is
                            interpreted as the pool lo(w) end.
                        </p>
                    </dd><dt><span class="term">pooled</span></dt><dd>
                        <p>
                            Just like pooled-lo, except that here the value from the table/sequence is interpreted
                            as the high end of the value pool.
                        </p>
                    </dd><dt><span class="term">hilo, </span><span class="term">legacy-hilo</span></dt><dd>
                        <p>
                            Define a custom algorithm for generating pools of values based on a single value from
                            a table or sequence.  These optimizers are not recommended for use.  They are maintained
                            (and mentioned) here simply for use by legacy applications that used these strategies
                            previously.
                        </p>
                    </dd></dl></div>

            <p>
                Applications can also implement and use their own optimizer strategies, as defined by the
                <code class="interfacename">org.hibernate.id.enhanced.Optimizer</code> contract.
            </p>
        </div>
    </div>

    <div class="section" title="6.4. Derived Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers-derived"/>6.4. Derived Identifiers</h2></div></div></div>
        
        <p>
            
            Ugh...
        </p>
    </div>
</div><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul xmlns:d="http://docbook.org/ns/docbook" class="docnav"><li class="previous"><a accesskey="p" href="ch05.html"><strong>Prev</strong>Chapter 5. Collections</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch07.html"><strong>Next</strong>Chapter 7. Natural Ids</a></li></ul></body></html>